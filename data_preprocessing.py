# -*- coding: utf-8 -*-
"""
Data Preprocessing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1R1QOfChDCiNL0q7cJG90g7xhXG1GTdox
"""

import numpy as np
from scipy import signal
import matplotlib.pyplot as plt
from numpy import genfromtxt

plt.rcParams['figure.dpi'] = 200 # change figure resolution


data = genfromtxt("PPG_Data/Rahul_PPG_Data.csv", delimiter=',')

print(data.shape)

print(data[0, 0].shape)

"""
Signal Filtering
Filter the measured signals using a band-pass Butterworth Filter.
"""

fc_low = 0.1 # cutoff frequency
fc_high = 18 # cutoff frequency
fs = 100 # sampling frequency
wn = [fc_low/(0.5*fs), fc_high/(0.5*fs)]
sos = signal.butter(4, wn, btype='bandpass', analog=False, output='sos') # 4th order band-pass digital butterworth filter with cut-off freqs of 0.1hz and 18hz

filtered_data = np.empty_like(data)

for x in range(1):
  for y in range(len(data[x])):
    for z in range(len(data[x, y])):
      sig = data[x, y,  ]
      filtered = signal.sosfilt(sos, sig)
      filtered_data[x, y, z] = filtered

filtered_data.shape

filtered_data[0, 0, 0][0].shape

"""Plot filter results on first sequence:"""

t = np.linspace(0, filtered_data[0, 0, 0].shape[1]/100, num=filtered_data[0, 0, 0].shape[1])

plt.plot(t, data[0, 0, 0][0])
plt.show()

plt.plot(t, filtered_data[0, 0, 0][0])
plt.show()

"""
Data Division
Divide each sequence of measurements into subsequences with a specific length of 1000 samples.
"""

divided_data = np.empty_like(filtered_data)

for x in range(len(filtered_data)):
  for y in range(len(filtered_data[x])):
    for z in range(len(filtered_data[x, y])):
      all = filtered_data[x, y, z][0]
      all_divided = np.split(all, np.arange(1000, len(all), 1000))
      incompletes_removed = [a for a in all_divided if a.shape[0] == 1000]
      divided_data[x, y, z] = np.stack(incompletes_removed)

divided_data.shape

divided_data[0, 0, 0].shape

"""
Data Normalization
Normalize each subsequence with 0 mean and unit variance.
"""

def normalize(x):
  return (x - np.mean(x))/np.std(x)

normalized_data = np.empty_like(divided_data)

for x in range(len(divided_data)):
  for y in range(len(divided_data[x])):
    for z in range(len(divided_data[x, y])):
      normalized_data[x, y, z] = np.apply_along_axis(normalize, 1, divided_data[x, y, z])

normalized_data.shape

normalized_data[0, 0, 0].shape

"""Plot the un-normalized and normalized data."""

segment_t = t = np.linspace(0, 10, num=1000)

plt.plot(segment_t, divided_data[0, 0, 0][3])
plt.show()

plt.plot(segment_t, normalized_data[0, 0, 0][3])
plt.show()

# Unfiltered data
all = data[0, 0, 0][0]
all_divided = np.split(all, np.arange(1000, len(all), 1000))
incompletes_removed = [a for a in all_divided if a.shape[0] == 1000]
incompletes_removed = np.stack(incompletes_removed)
plt.plot(segment_t, incompletes_removed[3])
plt.show()

np.save("/content/gdrive/MyDrive/ECE496 Capstone Project/Dataset/preprocessed_data.npy", normalized_data)
